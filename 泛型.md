在编译期，我们无法知道泛型就是什么类型，只有在运行时才会真正根据类型来构造和分配内存。

## 泛型接口

```java
public interface Generator<T> {
    public T next();
}
```

## 泛型类

```java
public class Container<K, V> {
    private K key;
    private V value;

    public Container(K k, V v) {
        key = k;
        value = v;
    }

    public K getKey() {
        return key;
    }
    public void setKey(K key) {
        this.key = key;
    }
    public V getValue() {
        return value;
    }
    public void setValue(V value) {
        this.value = value;
    }
}
```

## 泛型方法

一个基本的原则是：无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛化，那么应该有限采用泛型方法。

```java
public class Main {
    public static <T> void out(T... args) {
        for (T t : args) {
            System.out.println(t);
        }
    }
    public static void main(String[] args) {
        out("findingsea", 123, 11.11, true);
    }
}
```

## 类型擦除

```
Class c1 = new ArrayList<Integer>().getClass();
Class c2 = new ArrayList<String>().getClass(); 
System.out.println(c1 == c2);

/* Output
true
*/
```

本质上，ArrayList&lt;Integer&gt; 和 ArrayList&lt;String&gt; 是完全不同的类型，但是Java泛型的类型擦除，这两种类型都被编译器擦除成了ArrayList类型。故泛型有个先天缺点：在泛型代码内部，无法获得任何有关泛型参数类型的信息。

```
List<Integer> list = new ArrayList<Integer>();
Map<Integer, String> map = new HashMap<Integer, String>();
System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
System.out.println(Arrays.toString(map.getClass().getTypeParameters()));

/* Output
[E]
[K, V]
*/
```















